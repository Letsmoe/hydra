// Create a function that takes the processes arguments as parameter and parses them
// If the function encounters two dashes, it will assume that the argument is a flag
// If the function encounters a dash, it will assume that the argument is a flag alias
// The next argument after a named flag is it's value, which will be written into an object.
// Commands can be specified that will be executed if a value is found that matches it's name.
// The function will return an object with the arguments and their values.
import { generateHelp } from "./help.js";
function makeType(value, type) {
    if (type === "number") {
        return Number(value);
    }
    else if (type === "boolean") {
        return ["true", "y", "yes"].indexOf(type) >= 0;
    }
    return value;
}
function maybeCapture(opt) {
    if (typeof opt.capture === "function") {
        opt.capture();
    }
}
function parseArguments(args, expected, commands) {
    var requiredArgumentCount = 0;
    const objArgs = { _defaults: [] };
    // Loop through all values of the expected and write them into the objArgs
    for (const key in expected) {
        if (expected.hasOwnProperty(key)) {
            const element = expected[key];
            objArgs[key] = element.defaults || "";
            if (element.alias) {
                objArgs[element.alias] = element.defaults || "";
            }
            if (element.required) {
                requiredArgumentCount++;
            }
        }
    }
    for (let i = 0; i < args.length; i++) {
        let arg = args[i];
        let name, value;
        if (arg.startsWith("--")) {
            name = arg.substring(2);
            value = args[i + 1];
            if (name in expected) {
                objArgs[name] = makeType(value, expected[name].type);
                maybeCapture(expected[name]);
            }
            else {
                objArgs[name] = value;
            }
            i++;
        }
        else if (arg.startsWith("-")) {
            name = arg.substring(1);
            value = args[i + 1];
            let option = Object.values(expected).find((x) => x.alias === name);
            if (option) {
                objArgs[option.name] = makeType(value, option.type || "string");
                objArgs[name] = makeType(value, option.type || "string");
                maybeCapture(option);
            }
            else {
                objArgs[name] = value;
            }
            i++;
        }
        else if (arg.includes("=")) {
            const split = arg.split("=");
            name = split[0];
            value = split[1];
        }
        else {
            if (arg in commands) {
                let copyArgs = args.slice(0);
                // Remove the command from the cloned array and send it to the callback.
                copyArgs.splice(i, 1);
                commands[arg].callback(argParse(copyArgs));
                break;
            }
            else {
                objArgs._defaults.push(arg);
            }
        }
    }
    // Check if all required arguments are present
    if (requiredArgumentCount > 0) {
        for (const key in expected) {
            if (expected.hasOwnProperty(key)) {
                const element = expected[key];
                if (element.required && !objArgs[key]) {
                    console.log(`Missing required argument: --${key} | -${element.alias}`);
                    process.exit(1);
                }
            }
        }
    }
    return objArgs;
}
function argParse(argv) {
    const objCommands = {};
    const objOptions = {};
    var usageString = "";
    const obj = {
        get args() {
            return parseArguments(argv, objOptions, objCommands);
        },
        command(name, description, callback) {
            objCommands[name] = {
                name: name,
                description: description,
                callback: callback,
            };
            return obj;
        },
        option({ name, alias, type, defaults, description, required, capture }) {
            objOptions[name] = {
                name: name,
                alias: alias,
                type: type,
                default: defaults,
                description: description,
                required: required || false,
                capture: capture || null,
            };
            return obj;
        },
        options(opts) {
            opts.forEach((opt) => {
                this.option(opt);
            });
            return obj;
        },
        help() {
            this.option({ name: 'help', description: 'Prints this help message and exits.', required: false, alias: 'h', capture: () => {
                    generateHelp(objOptions, usageString);
                    process.exit(0);
                } });
            return obj;
        },
        usage(str) {
            usageString = str;
            return obj;
        },
    };
    return obj;
}
let args = argParse(process.argv.slice(2))
    .option({
    name: "aw",
    alias: "a",
    type: "boolean",
    description: "Show help",
    defaults: false,
})
    .command("new", "Some Command", (parser) => {
    console.log(parser.option({
        name: "name",
        alias: "n",
        type: "string",
        description: "Name of the project",
        required: true,
    }).args);
}).help().args;
